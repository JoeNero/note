# const与#define相比，区别和优点

## 一：区别


（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。
（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 
（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。
（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。
## 二：const优点


（1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
（2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。
（3）const可节省空间，避免不必要的内存分配，提高效率

# static 
## 隐藏

	当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。
	而加了static的变量会对其他文件隐藏

## 保持变量内容持久

	如果作为static局部变量在函数内定义，它的生存期为整个源程序，
	但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。
	退出该函数后， 尽管该变量还继续存在，但不能使用它。

## 默认初始化0

# new 和 delete
		new:分配内存、调用构造函数

##(1)new的底层也是通过malloc来开辟内存的
		new比malloc多一项功能，就是开辟完内存，还可以进行初始化操作
		如下：
				```
					int *p = new int(10);
				```
		上面是new的基本操作，10代表堆上开辟的整形内存的初始值；如果是自定义类类型的话，如下：
		```
		Test *p = new Test();
		```

		这个语句不仅会在堆上开辟Test类型大小的一块内存，还会调用Test类的默认构造函数构造一个对象出来，这些都是malloc办不到的！

##(2)delete比free多一项功能就是在释放内存之前，还可以析构指针指向的对象，new和delete配对使用，new[]和delete[]配对使用，尽量不要交叉使用，以免产生不可预期的问题。

##(3)new开辟内存失败是抛出bad_alloc类型的异常，因此代码上要捕获该类型的异常才能正确的判断堆内存是否分配成功；malloc内存开辟失败返回的是nullptr指针。

##(4）new和delete不仅仅是运算符，它们实际上是运算符重载函数的调用，对应的函数名是operator new和operator delete，可以在全局或者类的作用域中提供自定义的new和delete运算符的重载函数，以改变默认的malloc和free内存开辟释放行为，比如说实现内存池。

## delete this 一般用于线程自杀

# 悬空指针和野指针

```cpp
悬空指针:当所指向的对象被释放或者收回，但是没有让指针指向NULL，如下:

{
   char *dp = NULL;
   {
       char c;
       dp = &c;
   } 
  //变量c释放，dp变成空悬指针
}

void func()
{
    char *dp = (char *)malloc(A_CONST);
    free(dp);         //dp变成一个空悬指针
    dp = NULL;        //dp不再是空悬指针
    /* ... */
}
```

野指针:未初始化的指针

```
int func()
{
    char *dp;//野指针，没有初始化
    static char *sdp;//非野指针，因为静态变量会默认初始化为0
}
```

# sizeof和strlen的区别？

sizeof是操作符，参数为任意类型，主要计算类型占用内存大小。

strlen（）是函数，其函数原型为：extern unsigned int strlen(char *s）;其参数为char*,strlen只能计算以"\0"结尾字符串的长度，计算结果不包括"\0"。

```c++
char s[] = "1234567890";
cout << strlen(s) << endl;
cout << sizeof(s) << endl;
//输出结果
//10
//11
```

# dynamic_cast

强制类型转换

dynamic_cast用于**转换指针和和引用**，**不能用来转换对象** ——主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。在多态类型之间的转换主要使用dynamic_cast，因为类型**提供了运行时信息**。

# 智能指针

智能指针的设计思想：**将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。**

**unique_ptr**只允许基础指针的一个所有者。unique_ptr小巧高效；大小等同于一个指针且支持右值引用，从而可实现快速插入和对STL集合的检索。

**shared_ptr采用引用计数的智能指针，主要用于要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时）的情况。**当所有的shared_ptr所有者超出了范围或放弃所有权，才会删除原始指针。大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块。最安全的分配和使用动态内存的方法是调用**make_shared**标准库函数，此函数在动态分配内存中分配一个对象并初始化它，返回对象的shared_ptr。

# 函数指针和指针函数

指针函数:针函数本质是一个函数，其返回值为指针。

int *fun(int x,int y);

函数指针:其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。

int (*fun)(int x,int y);